# 拷贝算法
![[20231019_142257.png|800]]
<font color="#e36c09">copy</font>
![[20231019_142329.png|800]]
![[20231019_142646.png|800]]
![[20231019_142658.png|780]]
- 一般很少用，用等号直接赋值会更方便
## 替换算法 
1、replace
![[20231019_142732.png|800]]
![[20231019_143052.png|800]]
![[20231019_143057.png|800]]
- 会将满足条件的值都替换
2、replace_if
![[20231019_211436.png|800]]
![[20231019_144244.png]]
![[20231019_144254.png|800]]
### 互换算法
<font color="#e36c09">swap</font>
![[20231019_144317.png|800]]
![[20231019_144627.png|800]]
![[20231019_144638.png|800]]
#### 算术生成算法
![[20231019_144709 1.png|800]]
1、accumulate
![[20231019_211751.png|800]]
![[20231019_145049.png|800]]
- 第三个参数为一个起始值 一般为0即可（这个起始值也会相加）
2、fill
![[20231019_145131.png|800]]
![[20231019_145648.png|800]]
![[20231019_145655.png|800]]
- 重新填充，将原来的数据也会换成填充的值
##### 集合算法
![[20231019_145720.png|800]]
1、set_intersection
![[20231019_145747.png|750]]
![[20231019_150445.png|750]]
![[20231019_150518.png|800]]
- 两个容器必须是有序的；新容器必须要开辟空间，取小的的那一个容器的空间
2、set_union
![[20231019_150537.png|750]]
![[20231019_151211.png|800]]
![[20231019_151221.png|800]]
![[20231019_151227.png|800]]
3、set_difference
![[20231019_151300.png|760]]
![[20231019_152057.png|800]]
![[20231019_152105.png|750]]
![[20231019_152136.png|800]]
- 有两种情况，第一个容器的差集，第二个容器的差集，谁在前面就是谁的
###### 取小，取大算法
1、取小算法
 语法  min（int类型1，int类型2）；
2、取大算法
语法  max（int类型1，int类型2）；


注意：集合算法的容器必须都是有序的，开辟到第三个容器中是第三个容器都要先开辟空间
