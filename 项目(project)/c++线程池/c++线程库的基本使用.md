## 创建线程 ，传递参数
![[20240403_165247.png]]

## 阻塞主线程（异步，同步执行）
### join（）函数
![[20240403_165906.png]]
### detach（）函数

分离线程，将主线程与子线程（创建的线程）分离开，同步执行，如果主线程结束了，那么子线程会在后台继续执行直到完毕，且程序不会报错。

### joinable（）函数

判断线程是否可以调用join（）或detach（）函数，并返回bool值

![[20240403_170811.png]]
## 数据未定义问题
### 临时变量问题
![[20240403_211550.png]]
解决方案如下：
![[20240403_211518.png]]

###  局部变量问题
![[20240403_211649.png]]
![[20240403_212047.png]]

### 类作为函数调用问题
![[20240403_213205.png]]

线程中调用类成员函数会有些不同，特别理解。
![[20240403_213132.png]]
![[20240403_213435.png]]
### 私有成员函数问题
![[20240403_213745.png]]
解决方案：使用友元 friend，是外部能调用类中私有成员

## 并行问题
![[20240403_215308.png]]
![[20240403_215442.png]]
### 死锁问题
![[20240403_220230.png]]
- 获取所有权就是获取了锁对象，此时被获取的锁对象将不能被获取直至解锁。】
- 死锁问题的解决方案：将获取的顺序均改为相同顺序。
###  智能加锁，解锁
![[20240403_221025.png]]
![[20240403_221011.png]]
![[20240403_221040.png]]
![[20240403_222326.png]]
![[20240403_222625.png]]
- 加入defer_lock关键字后，将不会自动加锁，但依然会自动解锁（如果手动加锁）
![[20240403_222642.png]]

## call_once()函数应用及单例设计模式
![[PixPin_2024-04-04_11-05-17.png]]
![[20240404_095651.png]]
![[PixPin_2024-04-04_11-07-00.png]]
![[20240404_100416.png]]
- once_flag对象同样需要静态，因为静态成员只能调用静态变量。

## 条件变量与生产者消费者模型
![[20240404_100502.png]]
### 生产者与消费者模型
![[PixPin_2024-04-04_10-44-14.png]]
- 简单举例：
![[PixPin_2024-04-04_11-15-51.png]]
