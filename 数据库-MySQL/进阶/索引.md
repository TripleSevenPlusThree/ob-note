## 概述
-![[20240207_154630.png|1400]]
-![[20240207_155121.png|1300]]
## 索引结构
### 索引结构分类及支持情况
-![[20240207_155328.png|1000]]
-![[20240207_155433.png|1000]]
### b-tree结构
-![[20240207_155924.png|1000]]
-![[20240207_160415.png|1000]]
### b+tree结构
-![[20240207_160835.png|1000]]-![[20240207_160747.png|1000]]
### 哈希表结构（hash）
-![[20240207_161232.png|1200]]
-![[20240207_161336.png|1100]]
## 有关b+tree结构的思考
-![[20240207_161656.png|1200]]
## 索引分类
-![[20240207_161847.png|1200]]
-![[20240207_162117.png|1200]]
## 聚集索引与二级索引的区别
-![[20240207_162316.png|1400]]
-![[20240207_162500.png|1200]]
- 聚集索引中叶子结点中数据层存放对应id的行数据，而二级索引对应的是字段的数据
- 聚集索引性能更高
## 索引语法
-![[20240207_163315 1.png|1000]]
-![[20240207_164301.png|1120]]
# sql性能分析
## sql执行频率（次数）
-![[20240207_164800.png|1200]]
## 慢查询日志
-![[20240207_165023.png|1100]]
### 查询慢查询日志是否打开的语法
![[20240207_165145.png]]
## profile日志查询
-![[20240207_170230.png|1290]]
-![[20240207_170309.png|1200]]
## explain/desc 执行计划查询
-![[20240207_170901.png|1000]]
### explain执行计划各字段含义
-![[20240207_172334.png|1000]]
-![[20240207_172450.png|1000]]
- explain查询中主要关注type字段，以查看性能高低，其次看possible_key，key，key_len字段
## 索引的使用
### 验证索引效率
![[20240208_204108.png]]
### 最左前缀法则
![[20240208_204728.png]]
- 联合索引：创建索引时同时给多个字段创建了索引，那么这个索引就位联合索引；若只给一个字段创建索引那么为单列索引。
- 联合索引与单列索引的区别：联合索引的字段的根节点中存储有联合索引所有字段的数据，叶子节点为主键值，而单列索引的根节点为自己字段的值，叶子节点为主键值
- 在查询时，若条件中涉及联合索引的字段，没有使用联合索引中最左边的字段时，全部字段的索引都失效，若没有使用中间的某一个字段，则这个字段后面的字段的索引将失效。
### 范围查询
![[20240208_205514.png]]
- 解决方案：用大于等于（>=)或小于等于（<=）这种带等号的范围查询即可
### 覆盖索引
![[20240208_212638.png]]
- 理解：查询的字段的数据存储在条件字段的索引的根节点中，这就避免了回表查询，提高效率
- 若没有完全覆盖，想提高查询效率,解决方案为：为要查询的字段创建联合索引
### 前缀索引（重点关注）
![[20240208_220216.png]]
![[20240208_220918.png]]
- 操作有点复杂，需要使用时上网看黑马课程的教程如何使用。主要操作：
	1. 利用上述语法确定前缀长度（distinct关键字为去除重复的数据）
	2. 再创建即可